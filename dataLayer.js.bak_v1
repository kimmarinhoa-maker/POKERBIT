// ══════════════════════════════════════════════════════════════════════
//  dataLayer.js — Camada de Armazenamento (Poker Manager)
//  Centraliza todo acesso ao localStorage.
//
//  CARRY-FORWARD — hierarquia de leitura (backward-compat):
//    1. pm_saldo_prev[clube][weekKey][entityId]   ← escrita canônica
//    2. pm_finSnapshot[clube||weekKey].balances[entityId].saldoFinal
//    3. pm_fin[clube||weekKey][entityId].saldoAberto       (legado)
// ══════════════════════════════════════════════════════════════════════

window.DataLayer = (function () {
  'use strict';

  // ─── CHAVES DE STORAGE ───────────────────────────────────────────────
  const KEYS = {
    imports     : 'pm_imports',
    agentRB     : 'pm_agentRB',
    playerRB    : 'pm_playerRB',
    agentDirect : 'pm_agentDirect',
    rbSnapPlayers: 'pm_rbSnapPlayers',
    rbSnapAgents : 'pm_rbSnapAgents',
    fin         : 'pm_fin',
    finSnapshot  : 'pm_finSnapshot',
    weekLocked  : 'pm_weekLocked',
    saldoPrev   : 'pm_saldo_prev',
    carry       : 'pm_carry',
  };

  function _get(key) {
    try { return JSON.parse(localStorage.getItem(key) || '{}'); }
    catch(e) { console.error('[DataLayer] Erro ao ler ' + key, e); return {}; }
  }
  function _set(key, value) {
    localStorage.setItem(key, JSON.stringify(value));
  }

  // ─── LAYER 1: IMPORTAÇÕES ────────────────────────────────────────────

  function saveImport(weekKey, players, fileName) {
    var all = _get(KEYS.imports);
    all[String(weekKey)] = {
      players: players.map(function (p) {
        return {
          id: p.id, nick: p.nick, func: p.func, aid: p.aid, aname: p.aname,
          said: p.said, saname: p.saname, ganhos: p.ganhos, rake: p.rake,
          ggr: p.ggr, result: p.result, clube: p.clube, rakeback: p.rakeback || 0
        };
      }),
      fileName: fileName || '',
      importedAt: new Date().toISOString()
    };
    _set(KEYS.imports, all);
  }

  function loadImport(weekKey) {
    var all = _get(KEYS.imports);
    return all[String(weekKey)] || null;
  }

  function hasImport(weekKey) {
    return !!(_get(KEYS.imports)[String(weekKey)]);
  }

  function listImportedWeeks() {
    return Object.keys(_get(KEYS.imports));
  }

  // ─── LAYER 2: RB CONFIG & SNAPSHOT ──────────────────────────────────

  function getRBConfig() {
    return {
      agents : _get(KEYS.agentRB),
      players: _get(KEYS.playerRB)
    };
  }

  function getRBSnapshot(weekKey) {
    var sp = _get(KEYS.rbSnapPlayers);
    var sa = _get(KEYS.rbSnapAgents);
    return {
      players: sp[String(weekKey)] || null,
      agents : sa[String(weekKey)] || null
    };
  }

  // ─── LAYER 3: PAGAMENTOS (sempre editável) ───────────────────────────

  function getPayments(clubeWeekKey) {
    return _get(KEYS.fin)[clubeWeekKey] || {};
  }

  function savePayments(clubeWeekKey, data) {
    var all = _get(KEYS.fin);
    all[clubeWeekKey] = data;
    _set(KEYS.fin, all);
  }

  // ─── LAYER 4: CARRY-FORWARD ──────────────────────────────────────────

  /**
   * Lê o carry de uma agência para um clube/semana.
   * (acesso legado por agKey — mantido para compatibilidade)
   *
   * @param {string} clube
   * @param {string} weekKey
   * @returns {Object} mapa { agKey → saldoFinal }
   */
  function getCarry(clube, weekKey) {
    var all = _get(KEYS.carry);
    return all[clube + '||' + String(weekKey)] || {};
  }

  /**
   * Salva o carry de uma agência para um clube/semana.
   *
   * @param {string} clube
   * @param {string} weekKey
   * @param {Object} carryMap - { agKey → saldoFinal }
   */
  function saveCarry(clube, weekKey, carryMap) {
    var all = _get(KEYS.carry);
    all[clube + '||' + String(weekKey)] = carryMap;
    _set(KEYS.carry, all);
  }

  /**
   * Lê o saldo anterior de uma entidade (entityId) para um clube/semana.
   * Hierarquia: pm_saldo_prev → pm_finSnapshot → pm_fin.saldoAberto (legado)
   *
   * @param {string} entityId     - makeEntityId('ag', agKey) | makeEntityId('pl', id)
   * @param {string} clube
   * @param {string} weekKey      - semana ATUAL (não a anterior)
   * @param {number} currentIdx   - índice da semana atual em weeks[]
   * @param {Array}  weeks        - array de datas/chaves das semanas
   * @returns {number}
   */
  function getSaldoAnterior(entityId, clube, weekKey, currentIdx, weeks) {
    if (!clube || currentIdx <= 0) return 0;

    // 1ª fonte: pm_saldo_prev (escrita por fecharSemanaFinanceiro)
    var prevMap = _get(KEYS.saldoPrev);
    var clubePrev = prevMap[clube];
    if (clubePrev && clubePrev[weekKey] && typeof clubePrev[weekKey][entityId] === 'number') {
      return clubePrev[weekKey][entityId];
    }

    // 2ª fonte: pm_finSnapshot (lock de semana)
    // Busca SOMENTE a semana locked mais recente antes da atual.
    // INTENCIONAL: se a semana locked mais recente não tem dado para esta entidade,
    // retorna 0 — a entidade estava zerada naquele ponto. Não busca semanas ainda
    // mais antigas (evita carry de dados obsoletos). Comportamento herdado do original.
    var snapAll = _get(KEYS.finSnapshot);
    for (var i = currentIdx - 1; i >= 0; i--) {
      var sem = weeks[i];
      if (!sem) continue;
      var locked = _get(KEYS.weekLocked);
      if (!locked[String(sem)]) continue;  // pula semanas não-lockadas

      // Encontrou a semana locked mais recente — usa SÓ esta, depois para.
      var snapKey = clube + '||' + sem;
      var snap = snapAll[snapKey];
      if (snap && snap.balances && snap.balances[entityId]) {
        var val = snap.balances[entityId].saldoFinal;
        if (typeof val === 'number' && Math.abs(val) > 0.01) return val;
        return 0;  // entidade existia no snapshot com saldo zero
      }

      // 3ª fonte: pm_fin.saldoAberto (legado — mesma semana locked)
      var allFin = _get(KEYS.fin);
      var k = clube + '||' + sem;
      var ent = allFin[k] && allFin[k][entityId];
      if (ent && typeof ent.saldoAberto === 'number' && Math.abs(ent.saldoAberto) > 0.01) {
        return ent.saldoAberto;
      }
      return 0;  // semana locked encontrada, entidade sem registro → saldo zero
    }
    return 0;
  }

  /**
   * Grava o saldo anterior de uma entidade no pm_saldo_prev.
   * (Canônico — chamado por fecharSemanaFinanceiro)
   *
   * @param {string} entityId
   * @param {string} clube
   * @param {string} nextWeekKey - semana SEGUINTE (destino do carry)
   * @param {number} valor
   */
  function setCarryForEntity(entityId, clube, nextWeekKey, valor) {
    var prevMap = _get(KEYS.saldoPrev);
    if (!prevMap[clube]) prevMap[clube] = {};
    if (!prevMap[clube][nextWeekKey]) prevMap[clube][nextWeekKey] = {};
    prevMap[clube][nextWeekKey][entityId] = valor;
    _set(KEYS.saldoPrev, prevMap);
  }

  // ─── CARRY AUTO (computeCarryForWeek) ───────────────────────────────
  //
  // Calcula o carry automático da semana anterior.
  // FÓRMULA CANÔNICA: saldoFinal = saldoAnterior + resultado − ledgerNet
  // onde ledgerNet = entradas(dir='in') − saidas(dir='out')
  //
  // Nota: este método lê diretamente do localStorage para manter-se
  // independente do estado global da UI.
  // ─────────────────────────────────────────────────────────────────────

  /**
   * Calcula carry da semana anterior → semana atual para um clube.
   *
   * @param {string} clube
   * @param {number} currentWeekIdx - índice da semana atual
   * @param {Array}  weeksArr       - array de datas/chaves das semanas
   * @returns {Object} mapa { agKey → saldoFinal }
   */
  function computeCarryForWeek(clube, currentWeekIdx, weeksArr) {
    if (currentWeekIdx <= 0) return {};

    var prevWeekKey  = String(weeksArr[currentWeekIdx - 1]);
    var prevImport   = loadImport(prevWeekKey);
    if (!prevImport || !prevImport.players.length) return {};

    var prevPlayers  = prevImport.players.filter(function (p) { return p.clube === clube; });
    if (!prevPlayers.length) return {};

    // Agrupa por agência
    var agMap = {};
    prevPlayers.forEach(function (p) {
      var k = p.aname || '(sem agente)';
      if (!agMap[k]) agMap[k] = [];
      agMap[k].push(p);
    });

    var prevFinKey   = clube + '||' + prevWeekKey;
    var prevPayments = getPayments(prevFinKey);
    var prevCarry    = getCarry(clube, prevWeekKey);
    var snap         = getRBSnapshot(prevWeekKey);
    var agentDirectMap = _get(KEYS.agentDirect);
    var agentRBMap   = _get(KEYS.agentRB);
    var playerRBMap  = _get(KEYS.playerRB);

    var carry = {};

    Object.entries(agMap).forEach(function (kv) {
      var agKey   = kv[0];
      var players = kv[1];

      var totGanhos = players.reduce(function (s, p) { return s + (Number(p.ganhos) || 0); }, 0);
      var totRake   = players.reduce(function (s, p) { return s + (Number(p.rake)   || 0); }, 0);

      var isDirect = !!(agentDirectMap[agKey]);
      var totRB = 0;

      if (isDirect) {
        totRB = players.reduce(function (s, p) {
          var pct = 0;
          if (snap.players && snap.players[String(p.id)] !== undefined) {
            pct = Number(snap.players[String(p.id)]) || 0;
          } else {
            var pOv = playerRBMap[String(p.id)];
            if (pOv !== undefined && pOv !== null && pOv !== '') {
              pct = Number(pOv) || 0;
            } else {
              var cfg = agentRBMap[agKey] || {};
              pct = Number(cfg.pctAgente != null ? cfg.pctAgente : cfg.pct) || 0;
            }
          }
          return s + (Number(p.rake) || 0) * pct / 100;
        }, 0);
      } else {
        var pctAg = 0;
        if (snap.agents && snap.agents[agKey] !== undefined) {
          pctAg = Number(snap.agents[agKey]) || 0;
        } else {
          var cfg = agentRBMap[agKey] || {};
          pctAg = Number(cfg.pctAgente != null ? cfg.pctAgente : cfg.pct) || 0;
        }
        totRB = totRake * pctAg / 100;
      }

      var resultado = totGanhos + totRB;

      // ── FÓRMULA CANÔNICA: ledgerNet = entradas − saidas ──────────────
      // dir='in'  → entradas (pagamento recebido pelo clube, reduz openBalance)
      // dir='out' → saidas   (pagamento enviado pelo clube, aumenta openBalance)
      var entradas = 0, saidas = 0;
      players.forEach(function (p) {
        Object.values(prevPayments).forEach(function (entity) {
          (entity.historico || []).forEach(function (h) {
            if (String(h.cpId || '') === String(p.id)) {
              if (h.dir === 'out') saidas   += (h.valor || 0);
              else                 entradas += (h.valor || 0);
            }
          });
        });
      });
      var ledgerNet = entradas - saidas;

      var saldoAnterior = Number(prevCarry[agKey]) || 0;

      // saldoFinal = saldoAnterior + resultado − ledgerNet (fórmula canônica)
      var saldoFinal = saldoAnterior + resultado - ledgerNet;
      carry[agKey] = saldoFinal;
    });

    return carry;
  }

  /**
   * Persiste carry ao trocar de semana ou lockar.
   *
   * @param {string} clube
   * @param {string} weekKey        - semana ATUAL
   * @param {number} currentWeekIdx
   * @param {Array}  weeksArr
   * @returns {Object} carry calculado
   */
  function persistCarry(clube, weekKey, currentWeekIdx, weeksArr) {
    var carry = computeCarryForWeek(clube, currentWeekIdx, weeksArr);
    saveCarry(clube, weekKey, carry);
    return carry;
  }

  // ─── WEEK LOCK ───────────────────────────────────────────────────────

  function isLocked(weekKey) {
    return !!(_get(KEYS.weekLocked)[String(weekKey)]);
  }

  // ─── API PÚBLICA ─────────────────────────────────────────────────────

  return {
    // Importações
    saveImport       : saveImport,
    loadImport       : loadImport,
    hasImport        : hasImport,
    listImportedWeeks: listImportedWeeks,

    // RB Config & Snapshot
    getRBConfig      : getRBConfig,
    getRBSnapshot    : getRBSnapshot,

    // Pagamentos
    getPayments      : getPayments,
    savePayments     : savePayments,

    // Carry
    getCarry         : getCarry,
    saveCarry        : saveCarry,
    getSaldoAnterior : getSaldoAnterior,
    setCarryForEntity: setCarryForEntity,

    // Carry auto
    computeCarryForWeek: computeCarryForWeek,
    persistCarry       : persistCarry,

    // Lock
    isLocked         : isLocked,
  };

})();
